Integration Tests
-----------------

This is a DocTest file, using the Python doctest format.

In an integration test, here's some of the globals you have to work with::

    >>> portal
    <PloneSite at /plone>

    >>> portal_name
    'plone'

    >>> folder
    <ATFolder at /plone/Members/test_user_1_>

    >>> user_name
    'test_user_1_'

    >>> user_password
    'secret'

    >>> user_role
    'test_role_1_'

    >>> app.REQUEST
    <HTTPRequest, URL=http://nohost>

    >>> app
    <Application at >

uwosh.double_blind_review integration testing.  I have chosen to impliment all
the tests as doctests in order to provide some explanation of the functionality.

This product installs a folderish object loaded with instructions at the root 
level of the portal which is only available to those with roles of "Site 
Administrator" or "Manager".  Check that the permissions  and workflow state
are correct.::
    >>> root_content = portal.listContent()
    >>> root_content
    ['eeny', 'meeny']
    >>> 'double-blind-review-instructions' in root_content
    True

    >>> from Products.CMFCore.utils import _checkPermission as checkPerm
    >>> from Products.CMFCore.permissions import AccessContentsInformation
    >>> instructions = portal['double-blind-review-instructions']
    >>> user = portal.acl_users._doAddUser('member', 'secret', ['Member'], [])
    >>> self.login('member')
    >>> checkPerm(AccessContentsInformation,instructions)

Good, generic users cannot access this information.  Now check that managers can.::
    >>> user = portal.acl_users._doAddUser('manager', 'secret', ['Manager'], [])
    >>> self.login('manager')
    >>> checkPerm(AccessContentsInformation,instructions)
    1

    >>> user = portal.acl_users._doAddUser('site manager', 'secret', ['Site Administrator'], [])
    >>> self.login('site manager')
    >>> checkPerm(AccessContentsInformation,instructions)
    1

The product adds two special roles that are used to control access to proposals
at different times: 1) 'submitter' anybody with this role can submit a proposal
(usually assigned to the Faculty group on my Campus); 2) 'Panelist' is a special
form of reviewer, used to allow access by the final decision panel to proposals
and reviews when they are in the 'panel_review' state.  Check that these exist,
since workflow behavior depends on these roles.::
    >>> roles = portal.acl_users.portal_role_manager.valid_roles()
    >>> 'Submitter' in roles
    True
    >>> 'Panelist' in roles
    True
    
Now check that the Dexterity type 'proposal_drop_box' has been defined and
follows the workflow 'proposal_folder_workflow'.::
    >>> workflows = portal.portal_workflow.listWorkflows()
    >>> 'proposal_folder_workflow' in workflows
    True
   
    >>> 'proposal_drop_box' in portal.portal_types
    True
   
    >>> assigned_workflow = portal.portal_workflow.getChainForPortalType(portal.portal_types.proposal_drop_box)
    >>> assigned_workflow.id == 'proposal_folder_workflow'
    True
    
Now iterate through all the roles on the portal and make sure that only 'manager'
and 'site manager' can create one of these drop boxes.::
    >>> for role in roles:
    ...    if role != 'manager'and role !='site manager' :
    ...        # we are looking for a different result for managers.
    ...        self.login(user_name)
    ...        #self.setRole(role)
    ...        portal.invokeFactory('portal.portal_types.proposal_drop_box', 'test drop box')
    RaiseError:
    ...
    Permission Denied

Now check our managers::
    >>> self.login('manager')
    >>> #self.setRole('manager')
    >>> portal.invokeFactory('portal.portal_types.proposal_drop_box', 'test manager drop box')

Could set up something for a response.::
    
    >>> self.login('site manager')
    >>> #self.setRole('site manager')
    >>> portal.invokeFactory('portal.portal_types.proposal_drop_box', 'test site manager drop box')
    
Convert a drop box that should have been created in the 'private' state
to 'open' (accepting submissions).::
    >>> working_drop = portal['test-site-manager-drop-box']
    >>> 'private' == portal.portal_workflow.getInfoFor(working_drop, 'review_state')
    True
    
    >>> portal.portal_workflow.doActionFor(working_drop, 'open')
    >>> 'open' == portal.portal_workflow.getInfoFor(working_drop, 'review_state')
    True

Now check that the Dexterity type 'mock_proposal' has been defined and
follows the workflow 'proposal_workflow'.::
    >>> workflows = portal.portal_workflow.getWorkflowIds()
    >>> 'proposal_workflow' in workflows
    True
   
    >>> 'mock_proposal' in portal.portal_types
    True
   
    >>> assigned_workflow = portal.portal_workflow.getChainForPortalType(portal.portal_types.mock_proposal)
    >>> assigned_workflow.id == 'proposal_workflow'
    True
    
Now we can test that members can add a proposal, but only submit if they also 
have the role of 'submitter'.  I'm going to be careful and make two new users
for this test.::
    >>> user = portal.acl_users._doAddUser('student1', 'secret', ['Member'], [])
    >>> user = portal.acl_users._doAddUser('faculty1', 'secret', ['Submitter'], [])
    >>> self.login('student1')
    >>> working_drop.invokeFactory('uwosh.double_blind_review.mock_proposal', 'proposal1')
    >>> proposal1 = working_drop['proposal1']
    >>> 'private' == portal.portal_workflow.getInfoFor(proposal1, 'review_state')
    True
    


